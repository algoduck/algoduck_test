import random
import time
import requests
import threading
import os
import logging

# 로그 설정
os.makedirs("log", exist_ok=True)
logging.basicConfig(
    filename="log/log.txt",
    filemode="w",  # 실행 시마다 새로 작성
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

BASE_URL = "https://algoduck.duckdns.org"
SUBMIT_URL = f"{BASE_URL}/submissions/test"
RESULT_URL_TEMPLATE = f"{BASE_URL}/submissions/test/{{submission_id}}"
N = 1000  # 제출 횟수

PROBLEM_IDS = [1000, 1001, 1002, 1003]
MEMBER_IDS = list(range(1, 101))
CODE_TYPES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5]

# 결과를 유도하는 코드
CODES = [
    [
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\t\n\tprivate static int N;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tN = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tsb.append("알고오리\\n");\n\t\t\t\n\t\tSystem.out.print(sb);\n\t}\n}',
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\t\n\tprivate static int N;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tN = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tsb.append("알고오리!!\\n");\n\t\t\t\n\t\tSystem.out.print(sb);\n\t}\n}',
        'import java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\t\n\tprivate static int N;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tN = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tsb.append("알고오리\\n");\n\t\t\t\n\t\tSystem.out.print(sb);\n\t}\n}',
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\t\n\tprivate static int N;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tN = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0; ; i++);\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\t\n\tprivate static int N;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint[] arr = new int[1_000_000_000];\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\t\n\tprivate static int N;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint[] arr = new int[N];\n\t\tarr[N] = 1;\n\t}\n}",
    ],
    [
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\t\n\tprivate static int A;\n\tprivate static int B;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tA = Integer.parseInt(st.nextToken());\n\t\tB = Integer.parseInt(st.nextToken());\n\t\n\t\tSystem.out.println((long)A + B);\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\t\n\tprivate static int A;\n\tprivate static int B;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tA = Integer.parseInt(st.nextToken());\n\t\tB = Integer.parseInt(st.nextToken());\n\t\n\t\tSystem.out.println(A + B);\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\t\n\tprivate static int A;\n\tprivate static int B;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tA = Long.parseLong(st.nextToken());\n\t\tB = Integer.parseInt(st.nextToken());\n\t\n\t\tSystem.out.println(A + B);\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\t\n\tprivate static int A;\n\tprivate static int B;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\twhile(true) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tA = Integer.parseInt(st.nextToken());\n\t\t\tB = Integer.parseInt(st.nextToken());\n\t\t\n\t\t\tSystem.out.println(A + B);\n\t\t}\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\t\n\tprivate static int A;\n\tprivate static int B;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\twhile(true);\n\t}\n}",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\t\n\tprivate static int A;\n\tprivate static int B;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint[] arr = new int[1_000_000_000];\n\t}\n}",
    ],
    [
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\n\tprivate static List<int[]>[] forest;\n\tprivate static boolean[] visited;\n\n\t// 각 군집의 루트 리스트\n\tprivate static final List<Integer> rootList = new ArrayList<>();\n\t// 각 군집에서 거리가 가장 먼 도시 사이의 거리 리스트\n\tprivate static final List<Long> answer = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\n\t\tforest = new ArrayList[N + 1];\n\t\tvisited = new boolean[N + 1];\n\t\tfor (int v = 1; v <= N; v++)\n\t\t\tforest[v] = new ArrayList<>();\n\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = Integer.parseInt(st.nextToken());\n\t\t\tint v2 = Integer.parseInt(st.nextToken());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\n\t\t\tforest[v1].add(new int[] { v2, w });\n\t\t\tforest[v2].add(new int[] { v1, w });\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tlong[] info = dfs(v, 0);\n\t\t\t\tint root = (int) info[0];\n\t\t\t\trootList.add(root);\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrays.fill(visited, false);\n\t\tfor(int root : rootList) {\n\t\t\tlong[] info = dfs(root, 0);\n\t\t\tint farthest = (int)info[0];\n\t\t\tlong dist = info[1];\n\n\t\t\tanswer.add(dist);\n\t\t}\n\t\t\n\t\tCollections.sort(answer);\n\t\tfor(long dist : answer)\n\t\t\tsb.append(dist).append("\\n");\n\t\tSystem.out.print(sb);\n\t} // main-end\n\n\tprivate static long[] dfs(int cv, long cdist) {\n\t\tlong[] res = { cv, cdist };\n\t\tvisited[cv] = true;\n\n\t\tfor (int[] edge : forest[cv]) {\n\t\t\tint nv = edge[0];\n\t\t\tlong ndist = cdist + edge[1];\n\n\t\t\tif (!visited[nv]) {\n\t\t\t\tlong[] nres = dfs(nv, ndist);\n\n\t\t\t\tif (res[1] < nres[1]) {\n\t\t\t\t\tres[0] = nres[0];\n\t\t\t\t\tres[1] = nres[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n} // Main-class-end',
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\n\tprivate static List<int[]>[] forest;\n\tprivate static boolean[] visited;\n\n\t// 각 군집의 루트 리스트\n\tprivate static final List<Integer> rootList = new ArrayList<>();\n\t// 각 군집에서 거리가 가장 먼 도시 사이의 거리 리스트\n\tprivate static final List<Long> answer = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\n\t\tforest = new ArrayList[N + 1];\n\t\tvisited = new boolean[N + 1];\n\t\tfor (int v = 1; v <= N; v++)\n\t\t\tforest[v] = new ArrayList<>();\n\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = Integer.parseInt(st.nextToken());\n\t\t\tint v2 = Integer.parseInt(st.nextToken());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\n\t\t\tforest[v1].add(new int[] { v2, w });\n\t\t\tforest[v2].add(new int[] { v1, w });\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tlong[] info = dfs(v, 0);\n\t\t\t\tint root = (int) info[0];\n\t\t\t\trootList.add(root);\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrays.fill(visited, false);\n\t\tfor(int root : rootList) {\n\t\t\tlong[] info = dfs(root, 0);\n\t\t\tint farthest = (int)info[0];\n\t\t\tlong dist = info[1];\n\n\t\t\tanswer.add(dist);\n\t\t}\n\t\t\n\t\tCollections.sort(answer);\n\t\tfor(long dist : answer)\n\t\t\tsb.append(dist).append("\\n");\n\t\tSystem.out.print(sb);\n\t} // main-end\n\n\tprivate static long[] dfs(int cv, long cdist) {\n\t\tlong[] res = { cv, cdist };\n\t\tvisited[cv] = true;\n\n\t\tfor (int[] edge : forest[cv]) {\n\t\t\tint nv = edge[0];\n\t\t\tlong ndist = cdist + edge[1];\n\n\t\t\tif (!visited[nv]) {\n\t\t\t\tlong[] nres = dfs(nv, ndist);\n\n\t\t\t\tif (res[1] > nres[1]) {\n\t\t\t\t\tres[0] = nres[0];\n\t\t\t\t\tres[1] = nres[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n} // Main-class-end',
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\n\tprivate static List<int[]>[] forest;\n\tprivate static boolean[] visited;\n\n\t// 각 군집의 루트 리스트\n\tprivate static final List<Integer> rootList = new ArrayList<>();\n\t// 각 군집에서 거리가 가장 먼 도시 사이의 거리 리스트\n\tprivate static final List<Long> answer = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\n\t\tforest = new ArrayList[N + 1];\n\t\tvisited = new boolean[N + 1];\n\t\tfor (int v = 1; v <= N; v++)\n\t\t\tforest[v] = new ArrayList<>();\n\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = Integer.parseInt(st.nextToken());\n\t\t\tint v2 = Integer.parseInt(st.nextToken());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\n\t\t\tforest[v1].add(new int[] { v2, w });\n\t\t\tforest[v2].add(new int[] { v1, w });\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tlong[] info = dfs(v, 0);\n\t\t\t\tint root = (int) info[0];\n\t\t\t\trootList.add(root);\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrays.fill(visited, false);\n\t\tfor(int root : rootList) {\n\t\t\tlong[] info = dfs(root, 0);\n\t\t\tint farthest = (int)info[0];\n\t\t\tlong dist = info[1];\n\n\t\t\tanswer.add(dist);\n\t\t}\n\t\t\n\t\tCollections.sort(answer);\n\t\tfor(long dist : answer)\n\t\t\tsb.append(dist).append("\\n");\n\t\tSystem.out.print(sb);\n\t} // main-end\n\n\tprivate static long[] dfs(int cv, long cdist) {\n\t\tlong[] res = { cv, cdist };\n\t\tvisited[cv] = true;\n\n\t\tfor (int[] edge : forest[cv]) {\n\t\t\tint nv = edge[0];\n\t\t\tlong ndist = cdist + edge[1];\n\n\t\t\tif (!visited[nv]) {\n\t\t\t\tlong[] nres = dfs(cv, ndist);\n\n\t\t\t\tif (res[1] < nres[1]) {\n\t\t\t\t\tres[0] = nres[0];\n\t\t\t\t\tres[1] = nres[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n} // Main-class-end',
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\n\tprivate static List<int[]>[] forest;\n\tprivate static boolean[] visited;\n\n\t// 각 군집의 루트 리스트\n\tprivate static final List<Integer> rootList = new ArrayList<>();\n\t// 각 군집에서 거리가 가장 먼 도시 사이의 거리 리스트\n\tprivate static final List<Long> answer = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\n\t\tforest = new ArrayList[N + 1];\n\t\tvisited = new boolean[N + 1];\n\t\tfor (int v = 1; v <= N; v++)\n\t\t\tforest[v] = new ArrayList<>();\n\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = Integer.parseInt(st.nextToken());\n\t\t\tint v2 = Integer.parseInt(st.nextToken());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\n\t\t\tforest[v1].add(new int[] { v2, w });\n\t\t\tforest[v2].add(new int[] { v1, w });\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tlong[] info = dfs(v, 0);\n\t\t\t\tint root = (int) info[0];\n\t\t\t\trootList.add(root);\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrays.fill(visited, false);\n\t\tfor(int root : rootList) {\n\t\t\tlong[] info = dfs(root, 0);\n\t\t\tint farthest = (int)info[0];\n\t\t\tlong dist = info[1];\n\n\t\t\tanswer.add(dist);\n\t\t}\n\t\t\n\t\tCollections.sort(answer);\n\t\tfor(long dist : answer)\n\t\t\tsb.append(dist).append("\\n");\n\t\tSystem.out.print(sb);\n\t} // main-end\n\n\tprivate static long[] dfs(int cv, long cdist) {\n\t\tlong[] res = { cv, cdist };\n\t\tvisited[cv] = true;\n\n\t\tfor (int[] edge : forest[cv]) {\n\t\t\tint nv = edge[0];\n\t\t\tlong ndist = cdist + edge[1];\n\n\t\t\tif (!visited[nv]) {\n\t\t\t\tlong[] nres = dfs(cv, ndist);\n\n\t\t\t\tif (res[1] < nres[1]) {\n\t\t\t\t\tres[0] = nres[0];\n\t\t\t\t\tres[1] = nres[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n} // Main-class-end',
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\n\tprivate static List<int[]>[] forest;\n\tprivate static boolean[] visited;\n\n\t// 각 군집의 루트 리스트\n\tprivate static final List<Integer> rootList = new ArrayList<>();\n\t// 각 군집에서 거리가 가장 먼 도시 사이의 거리 리스트\n\tprivate static final List<Long> answer = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\n\t\tforest = new ArrayList[N + 1];\n\t\tvisited = new boolean[N + 1];\n\t\tfor (int v = 1; v <= N; v++)\n\t\t\tforest[v] = new ArrayList<>();\n\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = Integer.parseInt(st.nextToken());\n\t\t\tint v2 = Integer.parseInt(st.nextToken());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\n\t\t\tforest[v1].add(new int[] { v2, w });\n\t\t\tforest[v2].add(new int[] { v1, w });\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tlong[] info = dfs(v, 0);\n\t\t\t\tint root = (int) info[0];\n\t\t\t\trootList.add(root);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int v = 1; v <= N; v++) {\n\t\t\tArrays.fill(visited, false);\n\t\t\tlong[] info = dfs(v, 0);\n\t\t\tint farthest = (int)info[0];\n\t\t\tlong dist = info[1];\n\n\t\t\tif(rootList.contains(v))\n\t\t\t\tanswer.add(dist);\n\t\t}\n\t\t\n\t\tCollections.sort(answer);\n\t\tfor(long dist : answer)\n\t\t\tsb.append(dist).append("\\n");\n\t\tSystem.out.print(sb);\n\t} // main-end\n\n\tprivate static long[] dfs(int cv, long cdist) {\n\t\tlong[] res = { cv, cdist };\n\t\tvisited[cv] = true;\n\n\t\tfor (int[] edge : forest[cv]) {\n\t\t\tint nv = edge[0];\n\t\t\tlong ndist = cdist + edge[1];\n\n\t\t\tif (!visited[nv]) {\n\t\t\t\tlong[] nres = dfs(nv, ndist);\n\n\t\t\t\tif (res[1] < nres[1]) {\n\t\t\t\t\tres[0] = nres[0];\n\t\t\t\t\tres[1] = nres[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n} // Main-class-end',
        'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final StringBuilder sb = new StringBuilder();\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\n\tprivate static List<int[]>[] forest;\n\tprivate static boolean[] visited;\n\n\t// 각 군집의 루트 리스트\n\tprivate static final List<Integer> rootList = new ArrayList<>();\n\t// 각 군집에서 거리가 가장 먼 도시 사이의 거리 리스트\n\tprivate static final List<Long> answer = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tint[][] graph = new int[N][N];\n\n\t\tforest = new ArrayList[N + 1];\n\t\tvisited = new boolean[N + 1];\n\t\tfor (int v = 1; v <= N; v++)\n\t\t\tforest[v] = new ArrayList<>();\n\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint v1 = Integer.parseInt(st.nextToken());\n\t\t\tint v2 = Integer.parseInt(st.nextToken());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\n\t\t\tforest[v1].add(new int[] { v2, w });\n\t\t\tforest[v2].add(new int[] { v1, w });\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (!visited[v]) {\n\t\t\t\tlong[] info = dfs(v, 0);\n\t\t\t\tint root = (int) info[0];\n\t\t\t\trootList.add(root);\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrays.fill(visited, false);\n\t\tfor(int root : rootList) {\n\t\t\tlong[] info = dfs(root, 0);\n\t\t\tint farthest = (int)info[0];\n\t\t\tlong dist = info[1];\n\n\t\t\tanswer.add(dist);\n\t\t}\n\t\t\n\t\tCollections.sort(answer);\n\t\tfor(long dist : answer)\n\t\t\tsb.append(dist).append("\\n");\n\t\tSystem.out.print(sb);\n\t} // main-end\n\n\tprivate static long[] dfs(int cv, long cdist) {\n\t\tlong[] res = { cv, cdist };\n\t\tvisited[cv] = true;\n\n\t\tfor (int[] edge : forest[cv]) {\n\t\t\tint nv = edge[0];\n\t\t\tlong ndist = cdist + edge[1];\n\n\t\t\tif (!visited[nv]) {\n\t\t\t\tlong[] nres = dfs(nv, ndist);\n\n\t\t\t\tif (res[1] <= nres[1]) {\n\t\t\t\t\tres[0] = nres[0];\n\t\t\t\t\tres[1] = nres[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n} // Main-class-end',
    ],
    [
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\t\n\tprivate static int[][] map;\n\tprivate static boolean[][] visited;\n\tprivate static final Queue<int[]> queue = new LinkedList<>();\n\t\n\tprivate static int cnt = 0;\n\tprivate static int answer = -1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tmap = new int[N][M];\n\t\tvisited = new boolean[N][M];\n\t\t\n\t\tfor(int y = 0; y < N; y++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int x = 0; x < M; x++) {\n\t\t\t\tmap[y][x] = Integer.parseInt(st.nextToken());\n\t\t\t\tif(map[y][x] == 0)\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(map[y][x] == 1) {\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tqueue.offer(new int[] {y, x, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cnt == 0)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tbfs();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}	//	main-end\n\t\n\tprivate static void bfs() {\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint cy = cur[0];\n\t\t\tint cx = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\t\n\t\t\tfor(int d = 0; d < 4; d++) {\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint nt = ct + 1;\n\t\t\t\t\n\t\t\t\tif(isIn(ny, nx) && map[ny][nx] == 0 && !visited[ny][nx]) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tif(cnt == 0) {\n\t\t\t\t\t\tanswer = nt;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tqueue.offer(new int[] {ny, nx, nt});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static final int[] dy = {0, 1, 0, -1};\n\tprivate static final int[] dx = {1, 0, -1, 0};\n\t\n\tprivate static boolean isIn(int y, int x) {\n\t\treturn (0 <= y && y < N) && (0 <= x && x < M);\n\t}\n}	//	Main-class-end",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\t\n\tprivate static int[][] map;\n\tprivate static boolean[][] visited;\n\tprivate static final Queue<int[]> queue = new LinkedList<>();\n\t\n\tprivate static int cnt = 0;\n\tprivate static int answer = -1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tmap = new int[N][M];\n\t\tvisited = new boolean[N][M];\n\t\t\n\t\tfor(int y = 0; y < N; y++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int x = 0; x < M; x++) {\n\t\t\t\tmap[y][x] = Integer.parseInt(st.nextToken());\n\t\t\t\tif(map[y][x] == 0)\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(map[y][x] == 1) {\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tqueue.offer(new int[] {y, x, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cnt == 0)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tbfs();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}	//	main-end\n\t\n\tprivate static void bfs() {\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint cy = cur[0];\n\t\t\tint cx = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\t\n\t\t\tfor(int d = 0; d < 3; d++) {\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint nt = ct + 1;\n\t\t\t\t\n\t\t\t\tif(isIn(ny, nx) && map[ny][nx] == 0 && !visited[ny][nx]) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tif(cnt == 0) {\n\t\t\t\t\t\tanswer = nt;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tqueue.offer(new int[] {ny, nx, nt});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static final int[] dy = {0, 1, 0, -1};\n\tprivate static final int[] dx = {1, 0, -1, 0};\n\t\n\tprivate static boolean isIn(int y, int x) {\n\t\treturn (0 <= y && y < N) && (0 <= x && x < M);\n\t}\n}	//	Main-class-end",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\t\n\tprivate static int[][] map;\n\tprivate static boolean[][] visited;\n\tprivate static final Queue<int[]> queue = new LinkedList<>();\n\t\n\tprivate static int cnt = 0;\n\tprivate static int answer = -1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tmap = new int[N][M];\n\t\tvisited = new boolean[N][M];\n\t\t\n\t\tfor(int y = 0; y < N; y++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int x = 0; x < M; x++) {\n\t\t\t\tmap[y][x] = Integer.parseInt(st.nextToken());\n\t\t\t\tif(map[y][x] == 0)\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(map[y][x] == 1) {\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tqueue.offer(new int[] {y, x, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cnt == 0)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tbfs();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}	//	main-end\n\t\n\tprivate static void bfs() {\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint cy = cur[0];\n\t\t\tint cx = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\t\n\t\t\tfor(int d = 0; d < 3; d++) {\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint nt = ct + 1;\n\t\t\t\t\n\t\t\t\tif(isIn(ny, nx) && map[ny][nx] == 0 && !visited[ny][nx]) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tif(cnt == 0) {\n\t\t\t\t\t\tanswer = nt;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tqueue.offer(new int[] {ny, nx, nt});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate final int[] dy = {0, 1, 0, -1};\n\tprivate static final int[] dx = {1, 0, -1, 0};\n\t\n\tprivate static boolean isIn(int y, int x) {\n\t\treturn (0 <= y && y < N) && (0 <= x && x < M);\n\t}\n}	//	Main-class-end",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\t\n\tprivate static int[][] map;\n\tprivate static boolean[][] visited;\n\tprivate static final Queue<int[]> queue = new LinkedList<>();\n\t\n\tprivate static int cnt = 0;\n\tprivate static int answer = -1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tmap = new int[N][M];\n\t\tvisited = new boolean[N][M];\n\t\t\n\t\tfor(int y = 0; y < N; y++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int x = 0; x < M; x++) {\n\t\t\t\tmap[y][x] = Integer.parseInt(st.nextToken());\n\t\t\t\tif(map[y][x] == 0)\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(map[y][x] == 1) {\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tqueue.offer(new int[] {y, x, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cnt == 0)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tbfs();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}	//	main-end\n\t\n\tprivate static void bfs() {\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint cy = cur[0];\n\t\t\tint cx = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\t\n\t\t\tfor(int d = 0; d < 3; d++) {\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint nt = ct + 1;\n\t\t\t\t\n\t\t\t\tif(isIn(ny, nx) && map[ny][nx] == 0 && !visited[ny][nx]) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tif(cnt == 0) {\n\t\t\t\t\t\tanswer = nt;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tqueue.offer(new int[] {ny, nx, nt});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static final int[] dy = {0, 1, 0, -1};\n\tprivate static final int[] dx = {1, 0, -1, 0};\n\t\n\tprivate static boolean isIn(int y, int x) {\n\t\treturn (0 <= y && y <= N) && (0 <= x && x < M);\n\t}\n}	//	Main-class-end",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\t\n\tprivate static int[][] map;\n\tprivate static boolean[][] visited;\n\tprivate static final Queue<int[]> queue = new LinkedList<>();\n\t\n\tprivate static int cnt = 0;\n\tprivate static int answer = -1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tmap = new int[N][M];\n\t\tvisited = new boolean[N][M];\n\t\t\n\t\tfor(int y = 0; y < N; y++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int x = 0; x < M; x++) {\n\t\t\t\tmap[y][x] = Integer.parseInt(st.nextToken());\n\t\t\t\tif(map[y][x] == 0)\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(map[y][x] == 1) {\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tqueue.offer(new int[] {y, x, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cnt == 0)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tbfs();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}	//	main-end\n\t\n\tprivate static void bfs() {\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint cy = cur[0];\n\t\t\tint cx = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\tqueue.offer(cur);\n\t\t\t\n\t\t\tfor(int d = 0; d < 3; d++) {\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint nt = ct + 1;\n\t\t\t\t\n\t\t\t\tif(isIn(ny, nx) && map[ny][nx] == 0 && !visited[ny][nx]) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tif(cnt == 0) {\n\t\t\t\t\t\tanswer = nt;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tqueue.offer(new int[] {ny, nx, nt});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static final int[] dy = {0, 1, 0, -1};\n\tprivate static final int[] dx = {1, 0, -1, 0};\n\t\n\tprivate static boolean isIn(int y, int x) {\n\t\treturn (0 <= y && y <= N) && (0 <= x && x < M);\n\t}\n}	//	Main-class-end",
        "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static StringTokenizer st;\n\n\tprivate static int N;\n\tprivate static int M;\n\t\n\tprivate static int[][] map;\n\tprivate static boolean[][] visited;\n\tprivate static final Queue<int[]> queue = new LinkedList<>();\n\t\n\tprivate static int cnt = 0;\n\tprivate static int answer = -1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tst = new StringTokenizer(br.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Integer.parseInt(st.nextToken());\n\t\t\n\t\tmap = new int[N][M];\n\t\tvisited = new boolean[N][M];\n\t\tboolean[][][][] checked = new boolean[N][M][N][M];\n\t\t\n\t\tfor(int y = 0; y < N; y++) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tfor(int x = 0; x < M; x++) {\n\t\t\t\tmap[y][x] = Integer.parseInt(st.nextToken());\n\t\t\t\tif(map[y][x] == 0)\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(map[y][x] == 1) {\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tqueue.offer(new int[] {y, x, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cnt == 0)\n\t\t\tSystem.out.println(0);\n\t\telse {\n\t\t\tbfs();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}	//	main-end\n\t\n\tprivate static void bfs() {\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint cy = cur[0];\n\t\t\tint cx = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\t\n\t\t\tfor(int d = 0; d < 3; d++) {\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tint nt = ct + 1;\n\t\t\t\t\n\t\t\t\tif(isIn(ny, nx) && map[ny][nx] == 0 && !visited[ny][nx]) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tif(cnt == 0) {\n\t\t\t\t\t\tanswer = nt;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tqueue.offer(new int[] {ny, nx, nt});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static final int[] dy = {0, 1, 0, -1};\n\tprivate static final int[] dx = {1, 0, -1, 0};\n\t\n\tprivate static boolean isIn(int y, int x) {\n\t\treturn (0 <= y && y < N) && (0 <= x && x < M);\n\t}\n}	//	Main-class-end",
    ],
]

LANGUAGE_ID = 1001
VERSION_ID = 1001

submission_times = {}  # {submission_id: start_time}
elapsed_times = []  # 각 제출의 소요 시간 기록


def submit_one():
    member_id = random.choice(MEMBER_IDS)
    problem_id = random.choice(PROBLEM_IDS)
    code_type = random.choice(CODE_TYPES)
    code = CODES[problem_id % 1000][code_type]

    payload = {
        "memberId": member_id,
        "problemId": problem_id,
        "sourceCode": code,
        "versionId": VERSION_ID,
    }

    try:
        response = requests.post(SUBMIT_URL, json=payload)
        response.raise_for_status()
        submission_id = response.json()["data"]["submissionId"]
        submission_times[submission_id] = time.time()
        logging.info(f"[SUBMIT] ID={submission_id} by member {member_id}, problem {problem_id}, type {code_type}")
        return submission_id
    except Exception as e:
        logging.error(f"[ERROR] Submit failed: {e}")
        return None


def wait_for_result(submission_id):
    try_count = 0
    while try_count < 1000:
        try:
            res = requests.get(RESULT_URL_TEMPLATE.format(submission_id=submission_id))
            res.raise_for_status()
            data = res.json()["data"]
            status = data["status"]
            if status != "JUDGING":
                end_time = time.time()
                duration = end_time - submission_times[submission_id]
                elapsed_times.append(duration)
                logging.info(f"[RESULT] ID={submission_id} → {status} ({duration:.2f} sec)")
                return
        except Exception as e:
            logging.error(f"[ERROR] Fetching result for {submission_id}: {e}")
        try_count += 1
        time.sleep(0.5)
    logging.warning(f"[TIMEOUT] ID={submission_id}")


def main():
    start = time.time()
    submission_ids = []

    for _ in range(N):
        sid = submit_one()
        if sid:
            submission_ids.append(sid)
        time.sleep(0.05)

    threads = []
    for sid in submission_ids:
        t = threading.Thread(target=wait_for_result, args=(sid,))
        t.start()
        threads.append(t)

    for t in threads:
        t.join()

    end = time.time()
    total_time = end - start

    if elapsed_times:
        avg = sum(elapsed_times) / len(elapsed_times)
        logging.info(f"평균 채점 소요 시간: {avg:.2f}초 (총 {len(elapsed_times)}건)")
    else:
        logging.warning("유효한 채점 결과가 없습니다.")

    logging.info(f"전체 테스트 소요 시간: {total_time:.2f}초")


if __name__ == "__main__":
    main()
